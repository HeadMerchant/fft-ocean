vec2 :: struct {
	x: f32
	y: f32
}

sac :: fn "llvm.sincos.f32"(radian: f32) -> vec2
sin :: fn "llvm.sin.f32"(radian: f32) -> f32
cos :: fn "llvm.cos.f32"(radian: f32) -> f32

mat4x4 :: [4][4]f32
# mat4x4 :: struct {
# 	data: [4][4]f32
# }

vec3 :: struct {
	x: f32
	y: f32
	z: f32
}

matVecMult :: fn(A: ^mat4x4, x: vec3) -> vec3 {
	return (
		x.x * A[0][0] + x.y*A[0][1] + x.z*A[0][2],
		x.x * A[1][0] + x.y*A[1][1] + x.z*A[1][2],
		x.x * A[2][0] + x.y*A[2][1] + x.z*A[2][2],
	)
}

matMul :: fn(a: ^mat4x4, b: ^mat4x4) -> mat4x4 {
	return [
		[a[0][0] * b[0][0] + a[0][1] * b[1][0] + a[0][2] * b[2][0] + a[0][3] * b[3][0], a[0][0] * b[0][1] + a[0][1] * b[1][1] + a[0][2] * b[2][1] + a[0][3] * b[3][1], a[0][0] * b[0][2] + a[0][1] * b[1][2] + a[0][2] * b[2][2] + a[0][3] * b[3][2], a[0][0] * b[0][3] + a[0][1] * b[1][3] + a[0][2] * b[2][3] + a[0][3] * b[3][3]],
		[a[1][0] * b[0][0] + a[1][1] * b[1][0] + a[1][2] * b[2][0] + a[1][3] * b[3][0], a[1][0] * b[0][1] + a[1][1] * b[1][1] + a[1][2] * b[2][1] + a[1][3] * b[3][1], a[1][0] * b[0][2] + a[1][1] * b[1][2] + a[1][2] * b[2][2] + a[1][3] * b[3][2], a[1][0] * b[0][3] + a[1][1] * b[1][3] + a[1][2] * b[2][3] + a[1][3] * b[3][3]],
		[a[2][0] * b[0][0] + a[2][1] * b[1][0] + a[2][2] * b[2][0] + a[2][3] * b[3][0], a[2][0] * b[0][1] + a[2][1] * b[1][1] + a[2][2] * b[2][1] + a[2][3] * b[3][1], a[2][0] * b[0][2] + a[2][1] * b[1][2] + a[2][2] * b[2][2] + a[2][3] * b[3][2], a[2][0] * b[0][3] + a[2][1] * b[1][3] + a[2][2] * b[2][3] + a[2][3] * b[3][3]],
		[a[3][0] * b[0][0] + a[3][1] * b[1][0] + a[3][2] * b[2][0] + a[3][3] * b[3][0], a[3][0] * b[0][1] + a[3][1] * b[1][1] + a[3][2] * b[2][1] + a[3][3] * b[3][1], a[3][0] * b[0][2] + a[3][1] * b[1][2] + a[3][2] * b[2][2] + a[3][3] * b[3][2], a[3][0] * b[0][3] + a[3][1] * b[1][3] + a[3][2] * b[2][3] + a[3][3] * b[3][3]],
	]
}

translate :: fn(x: vec3) -> mat4x4 {
	return [
		[ 1.,  0.,  0., 0.],
		[ 0.,  1.,  0., 0.],
		[ 0.,  0.,  1., 0.],
		[x.x, x.y, x.z, 1.],
	]
}

tan :: fn "llvm.tan.f32"(radian: f32) -> f32
pi :: 3.14159
deg2rad :: 2*pi/180

perspective :: fn (fovy: f32, aspect: f32, zn: f32, zf: f32) -> mat4x4 {
	yscale := 1. / tan(fovy * .5)
	xscale := yscale / aspect
	return [
		[xscale, 0., 0., 0.],
		[0., yscale, 0., 0.],
		[0., 0., zf / ( zn - zf ), -1.],
		[0., 0., zn * zf / ( zn - zf ), 0.],
	]
}
