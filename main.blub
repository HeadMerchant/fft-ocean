cu :: import "cuda.blub"
gl :: import "gl.blub"
sg :: gl.sg

app :: @cImport("sokol/sokol_app.h", "sapp_")
time :: @cImport("sokol/sokol_time.h", "stm_")
log :: @cImport("sokol/sokol_log.h", "slog_")
@cInclude("sokol/sokol_glue.h")
@cInclude("shaders/triangle.glsl.h")


glueEnv :: fn "sglue_environment"() -> sg.environment
swapchain :: fn "sglue_swapchain"() -> sg.swapchain
math :: import "math.blub"
fmt :: import "fmt.blub"
print :: fmt.print
println :: fmt.println

state : struct {
    pip: sg.pipeline
    bind: sg.bindings
    passAction: sg.pass_action
} = ()

input : struct {
	mousePos: math.vec2
	mouseDown: bool
	forward: bool
	backward: bool
	left: bool
	right: bool
} = ()

cleanup :: fn() {
	sg.shutdown()
}

vs := \"#version 410
	\"uniform vec4 mvp[4];
    \"layout(location = 0) in vec2 position;
    \"layout(location = 0) out vec4 color;
    \"layout(location = 1) in vec3 color0;
    \"void main() {
	\"    vec2 pos[4];
	\"    pos[0] = vec2(-0.5,  0.5);
	\"    pos[1] = vec2( 0.5,  0.5);
	\"    pos[2] = vec2( 0.5, -0.5);
	\"    pos[3] = vec2(-0.5, -0.5);
	\"    mat4 mv2 = mat4(
	\"    	vec4(1., 0., 0., 0.),
	\"    	vec4(0., 1., 0., 0.),
	\"    	vec4(0., 0., 1., 0.),
	\"    	vec4(0., 0., 0., 1.)
	\"    );
	\"    vec3 usedPos = vec3(pos[gl_VertexID], 1.);
	\"    //vec3 usedPos = position;
	\"    //gl_Position = mv2 * vec4(usedPos., 1.);
	\"    gl_Position = mat4(mvp[0], mvp[1], mvp[2], mvp[3]) * vec4(usedPos, 1.);
	\"    //color = vec4(color0, 1.);
    \"    color = vec4(position.x, color0.y, mvp[3].x, 1.);
    \"}\x00

fs := \"#version 410
    \"layout(location = 0) out vec4 frag_color;
    \"layout(location = 0) in vec4 color;
    \"void main()
    \"{
    \"    frag_color = color;
    \"}\x00

startTime : u64 = 0

init :: fn() {
	println("Starting window")
	desc := sg.desc(
		environment = glueEnv(),
		logger = (func = log.func)
	)
	sg.setup(^desc)
	println("gfx setup called")

	# 0 - 1
	# | \ |
	# 3 - 2
	verts : @align(16) [20]f32 = [
		-1,  1,   1, 1, 1,
		 1,  1,   1, 1, 1,
		 1, -1,   1, 1, 1,
		-1, -1,   1, 1, 1,
	]
	indices : [6]u16 = [
		0, 2, 1,
		# TODO: come back and flip this
		0, 3, 2,
	]
	vertBufferDesc := sg.buffer_desc(
		data = sg.range(^verts, @type(verts).size),
		label = c"vertex-buf",
	)
	indexBufferDesc := sg.buffer_desc(
		data = sg.range(^indices, @type(indices).size),
		usage = (index_buffer = true),
		label = c"index-buf",
	)
	vertBuffer := sg.make_buffer(^vertBufferDesc)
	indexBuffer := sg.make_buffer(^indexBufferDesc)
	state.bind.vertex_buffers[0] = vertBuffer
	print("Vertex buffer state:")
	bufferState := sg.query_buffer_state(vertBuffer)

	if (bufferState == .INITIAL) println("INITIAL")
	else if (bufferState == .ALLOC) println("ALLOC")
	else if (bufferState == .VALID) println("VALID")
	else if (bufferState == .FAILED) println("FAILED")
	else if (bufferState == .INVALID) println("INVALID")

	state.bind.index_buffer = indexBuffer

	vertReadback : [5]f32 = [5, 5, 5, 5, 5]
	i: u64 = 0
	sentinel := vertReadback[i]
	gl.readBack(vertBuffer, 4*(i+1), ^vertReadback)

	if (vertReadback[i] == sentinel) println("unwritten")
	else if (vertReadback[i] == verts[i]) println("read correctly")
	else println("new value")

	println("Original value")
	fmt.printBin(@bitCast(verts[i]))
	println("")
	fmt.printHex(@bitCast(verts[i]))
	println("")


	println("Read back value:")
	fmt.printBin(@bitCast(vertReadback[i]))
	println("")
	fmt.printHex(@bitCast(vertReadback[i]))
	println("")

	info := sg.query_buffer_info(vertBuffer)
	
	shader := sg.shader_desc(
		vertex_func = (
			source = ^vs.data[0],
			entry = c"main",
		),
		fragment_func = (
			source = ^fs.data[0],
			entry = c"main",
		),
		label = c"triangle_shader"
	)
	shader.attrs[0] = (
		base_type = .FLOAT,
		glsl_name = c"position"
	)
	shader.attrs[1] = (
		base_type = .FLOAT,
		glsl_name = c"color0"
	)
	shader.uniform_blocks[0] = (
		stage = .VERTEX,
		size = math.mat4x4.size,
	)
	shader.uniform_blocks[0].glsl_uniforms[0] = (
		type = .FLOAT4,
		array_count = 4,
		glsl_name = c"mvp"
	)

	pipelineDesc := sg.pipeline_desc(
		shader = sg.make_shader(^shader),
		cull_mode = .FRONT,
		index_type = .UINT16,
	)

	pipelineDesc.layout.attrs[0].format = .FLOAT2
	pipelineDesc.layout.attrs[1].format = .FLOAT3
	# pipelineDesc.layout.buffers[0].stride = f32.size * 6

	state.pip = sg.make_pipeline(^pipelineDesc)

	state.passAction.colors[0] = (
		load_action = .CLEAR,
		clear_value = (0, 0, 0, 1)
	)

	time.setup()
	startTime = time.now()
}

frame :: fn() {
	seconds := time.sec(time.since(startTime))
	handle : cu.fftHandle = 0
	result := cu.plan2d(^handle, 16, 16, .C2C)
	if (result == .Success) {
		# print_u32(@numCast(time.since(startTime)))
		# println("")
		# println("FFT success!!!")
	} else {
		println("Failed fft")
	}
	w := app.widthf()
	h := app.heightf()
	red := math.sin(@numCast(seconds))
	state.passAction.colors[0].clear_value.r = red * red

	pass := sg.pass(action = state.passAction, swapchain = swapchain())
	sg.begin_pass(^pass)
    sg.apply_pipeline(state.pip)
    sg.apply_bindings(^state.bind)

	# viewMatrix := math.perspective(math.deg2rad * 60, w/h, .01, 10)
	# viewMatrix: math.mat4x4 = [
	# 	[  1,   0,   0,  0,],
	# 	[  0,   1,   0,  0,],
	# 	[  0,   0,   1,  0,],
	# 	[ red, 0.1,   0,  1,],
	# ]
	viewMatrix := math.translate(math.vec3(1., .1, 0))
	uniformRange := sg.range(^viewMatrix, @type(viewMatrix).size)
	sg.apply_uniforms(0, ^uniformRange)

    sg.draw(0, 6, 1)
    sg.end_pass()
    sg.commit()
}

event :: fn(e: ^app.event) {
	if (e.type == .MOUSE_DOWN) {
		println("mouse down")
		input.mouseDown = true
	} else if (e.type == .MOUSE_UP) {
		println("mouse up")
		input.mouseDown = false
	} else if (e.type == .KEY_DOWN) {
		if (e.key_code == .W) {
			input.forward = true
		} else if (e.key_code == .A) {
			input.left = true
		} else if (e.key_code == .S) {
			input.backward = true
		} else if (e.key_code == .D) {
			input.right = true
		}
	} else if (e.type == .KEY_UP) {
		if (e.key_code == .W) {
			input.forward = false
		} else if (e.key_code == .A) {
			input.left = false
		} else if (e.key_code == .S) {
			input.backward = false
		} else if (e.key_code == .D) {
			input.right = false
		}
	}
}

sokol_main :: fn(argc: s32, argv: [^][^]u8) -> app.desc {
	return (
		init_cb = init,
		frame_cb = frame,
		cleanup_cb = cleanup,
		event_cb = event,
		width = 640,
		height = 480,
		window_title = c"Triangle",
	)
}
