@cIncludeDir("sokol")
@link("GL")
@link("X11")
@link("Xi")
@link("Xcursor")
@link("dl")
@link("pthread")
@link("m")
@cDefine("SOKOL_IMPL")
@cDefine("SOKOL_GLCORE")

sg :: @cImport("sokol/sokol_gfx.h", "sg_")
app :: @cImport("sokol/sokol_app.h", "sapp_")
time :: @cImport("sokol/sokol_time.h", "stm_")
@cInclude("sokol/sokol_glue.h")
@cInclude("shaders/triangle.glsl.h")

cu :: import "cuda.blub"

glueEnv :: fn "sglue_environment"() -> sg.environment
swapchain :: fn "sglue_swapchain"() -> sg.swapchain
math :: import "math.blub"

state : struct {
    pip: sg.pipeline
    bind: sg.bindings
    passAction: sg.pass_action
} = ()

input : struct {
	mousePos: math.vec2
	mouseDown: bool
	forward: bool
	backward: bool
	left: bool
	right: bool
} = ()

cleanup :: fn() {
	sg.shutdown()
}

write :: fn(fd: s32, buf: [^]u8, count: usize)

print :: fn(buf: []u8) {
	stdout :: 1
	write(stdout, buf.data, buf.length)
}

println :: fn(buf: []u8) {
	print(buf)
	print("\n")
}

vs := \"#version 410
    \"layout(location = 0) in vec4 position;
    \"layout(location = 0) out vec4 color;
    \"layout(location = 1) in vec4 color0;
    \"void main()
    \"{
    \"    gl_Position = position;
    \"    color = color0;
    \"}\x00

fs := \"#version 410
    \"layout(location = 0) out vec4 frag_color;
    \"layout(location = 0) in vec4 color;
    \"void main()
    \"{
    \"    frag_color = color;
    \"}\x00

shaderDesc :: fn() -> sg.shader_desc {
	desc := sg.shader_desc(
		vertex_func = (
			source = ^vs.data[0],
			entry = ^c"main"[0]
		),
		fragment_func = (
			source = ^fs.data[0],
			entry = ^c"main"[0]
		),
		label = ^c"triangle_shader"[0]
	)
	desc.attrs[0] = (
		base_type = .FLOAT,
		glsl_name = ^c"position"[0]
	)
	desc.attrs[1] = (
		base_type = .FLOAT,
		glsl_name = ^c"color0"[0]
	)
	return desc
}

print_u32 :: fn(x: u32) {
	buf : [10]u8 = ---
	if (x == 0) {
		buf[9] = 48
		print(buf[9.<])
	}
	i := 10
	y := x
	while (y > 0) {
		i = i - 1
		digit := y % 10
		y = y / 10
		buf[i] = 48 + @numCast(digit, u8)
	}
	print(buf[i.<])
}

startTime : u64 = 0

init :: fn() {
	println("Starting window")
	desc := sg.desc(
		environment = glueEnv(),
		# logger = (func = slog.func)
	)
	sg.setup(^desc)
	println("gfx setup called")

	# 1 - 2
	# | / |
	# 0 - 3
	verts := [
		0,  0.5, 0.5,    1., 1, 1., 1.,
		0.5,  -0.5, 0.5,    1., 0, 0., 1.,
		-0.5,  -0.5, 0.5,    0., 1, 0., 1.,
		1,  0, 0.5,    0., 0, 1., 1.,
	]
	indices : [6]u16 = [
		0, 2, 1,
		# TODO: come back and flip this
		0, 3, 2,
	]
	vertBufferDesc := sg.buffer_desc(
		data = sg.range(^verts, @type(verts).size)
	)
	indexBufferDesc := sg.buffer_desc(
		data = sg.range(^indices, @type(indices).size),
		usage = (index_buffer = true),
	)
	println("Made vertBufferDesc")
	state.bind.vertex_buffers[0] = sg.make_buffer(^vertBufferDesc)
	state.bind.index_buffer = sg.make_buffer(^indexBufferDesc)
	
	println("Made buffer")
	shader := shaderDesc()
	pipelineDesc := sg.pipeline_desc(
		shader = sg.make_shader(^shader),
		index_type = .UINT16,
	)

	println("Made pipeline desc")
	pipelineDesc.layout.attrs[0].format = .FLOAT3
	pipelineDesc.layout.attrs[1].format = .FLOAT4

	state.pip = sg.make_pipeline(^pipelineDesc)
	println("Made pipeline")

	state.passAction.colors[0] = (
		load_action = .CLEAR,
		clear_value = (0, 0, 0, 1)
	)

	time.setup()
	startTime = time.now()
}

frame :: fn() {
	seconds := time.sec(time.since(startTime))
	handle : cu.fftHandle = 0
	result := cu.plan2d(^handle, 16, 16, .C2C)
	if (result == .Success) {
		print_u32(99)
		# println("FFT success!!!")
	} else {
		println("Failed fft")
	}
	w := app.widthf()
	h := app.heightf()
	red := math.sin(@numCast(seconds))
	state.passAction.colors[0].clear_value.b = red * red

	pass := sg.pass(action = state.passAction, swapchain = swapchain())
	sg.begin_pass(^pass)
    sg.apply_pipeline(state.pip)
    sg.apply_bindings(^state.bind)
	# println("Applied bindings")

	# viewMatrix := math.perspective(math.deg2rad * 60, w/h, .01, 10)
	viewMatrix := math.translate(math.vec3(0, 0, 0))
	# uniformRange := sg.range(^viewMatrix, @type(viewMatrix).size)
	# println("making uniform")
	# sg.apply_uniforms(0, ^uniformRange)
	# println("applying uniform")

    sg.draw(0, 3, 1)
    sg.end_pass()
    sg.commit()
}

event :: fn(e: ^app.event) {
	if (e.type == .MOUSE_DOWN) {
		println("mouse down")
		input.mouseDown = true
	} else if (e.type == .MOUSE_UP) {
		println("mouse up")
		input.mouseDown = false
	} else if (e.type == .KEY_DOWN) {
		if (e.key_code == .W) {
			input.forward = true
		} else if (e.key_code == .A) {
			input.left = true
		} else if (e.key_code == .S) {
			input.backward = true
		} else if (e.key_code == .D) {
			input.right = true
		}
	} else if (e.type == .KEY_UP) {
		if (e.key_code == .W) {
			input.forward = false
		} else if (e.key_code == .A) {
			input.left = false
		} else if (e.key_code == .S) {
			input.backward = false
		} else if (e.key_code == .D) {
			input.right = false
		}
	}
}

sokol_main :: fn(argc: s32, argv: [^][^]u8) -> app.desc {
	return (
		init_cb = init,
		frame_cb = frame,
		cleanup_cb = cleanup,
		event_cb = event,
		width = 640,
		height = 480,
		window_title = ^c"Triangle"[0],
	)
}
